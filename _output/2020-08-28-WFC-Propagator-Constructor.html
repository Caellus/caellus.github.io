<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Odin</title>
	<style> 
		.mono{font-family: Courier, monospace;} 
		body{margin: 0 auto; width: 36em;}
	</style>
</head>
<body>

<p class="mono">
┌──────┐<br>
│ Home │ Blog │ Wiki │ About<br>
└──────┘<br>
───────────────────────────────────────────────────────────────
</p>

</body>
</html>
	
<p>The propagator (and the constructor system) is probably the most often misunderstood part of the wfc algorithm. The basic idea is that it's a way to easily access the adjacency data generated in the tile generation stage. The propagator constructor generates four lists of booleans (one list for each side of the tile) for every tile, where each boolean corresponds to whether or not a tile can go in the adjacent location which the list is describing. Now that's a lot of words, so let's see how it looks.</p> <p>Lets just focus on a simple example. Here are our tiles</p> <div class="figure"> <img src="/assets/images/post-4/notes-1.png" alt="Tiles" /> <p class="caption">Tiles</p> </div> <p>and here are the tiles with color data, where each number corresponds to a unique arrangement of colors</p> <div class="figure"> <img src="/assets/images/post-4/notes-2.png" alt="Tiles with colors" /> <p class="caption">Tiles with colors</p> </div> <p>Now let's just focus on tile C. What we now need to figure out is what tiles can go above tile C, which we do by comparing the top color value of tile C with the bottom color values of all of the tiles (including C itself)</p> <div class="figure"> <img src="/assets/images/post-4/notes-3.png" alt="Tile comparison" /> <p class="caption">Tile comparison</p> </div> <p>This check finds that the only tile which fits above tile C is tile A, and so the boolean at the index of tile A is set to true for tile C's &quot;top&quot; adjacency index, and all the others are set to false.</p> <div class="figure"> <img src="/assets/images/post-4/notes-4.png" alt="Top adjacency" /> <p class="caption">Top adjacency</p> </div> <p>We do this for all of the tiles and all of their edges, and at the end we'll have an array where each primary index corresponds to the tile you're checking, which has top, bottom, left, and right arrays where each value in those array corresponds to whether or not a given tile can go in that location.</p> <div class="figure"> <img src="/assets/images/post-4/notes-5.png" alt="Adjacency structure" /> <p class="caption">Adjacency structure</p> </div> <p>For example, if we wanted to see if tile B could go above tile A we would get the value of adjacencyIndex[A.index].top[B.index], where adjacencyIndex is the primary table of adjacency data. In plain English this would be something like &quot;get the value at tile B above tile A&quot;. While it might still be a bit confusing, this data structure is super useful because it allows us to quickly see if a tiles can be adjacent just by plugging in indices. You could ignore this step, but you would then have to have to perform the tests we did here every time you wanted to check the adjacency of two tiles (which would be super slow and unnecessary)</p> <p>Now I promised some actual code, so here you go!</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">for</span> i <span class="ot">=</span> <span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>wfc<span class="ot">.</span>tiles <span class="kw">do</span> <span class="do">-- go through all tiles</span> <span class="kw">local</span> currentTile <span class="ot">=</span> wfc<span class="ot">.</span>tiles<span class="ot">[</span>i<span class="ot">]</span> <span class="do">-- get current tile</span> <span class="kw">local</span> tileAdjacency <span class="ot">=</span> <span class="ot">{}</span> <span class="do">-- make a new adjacency table</span> tileAdjacency<span class="ot">.</span>top <span class="ot">=</span> <span class="ot">{}</span> <span class="do">-- list of possible tiles above</span> <span class="kw">for</span> j <span class="ot">=</span> <span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>wfc<span class="ot">.</span>tiles <span class="kw">do</span> <span class="do">-- check other tiles</span> <span class="kw">local</span> checkTile <span class="ot">=</span> wfc<span class="ot">.</span>tiles<span class="ot">[</span>j<span class="ot">]</span> <span class="kw">if</span> checkTile<span class="ot">.</span>color<span class="ot">.</span>bottom <span class="ot">==</span> currentTile<span class="ot">.</span>color<span class="ot">.</span>top <span class="kw">then</span> tileAdjacency<span class="ot">.</span>top<span class="ot">[</span>j<span class="ot">]</span> <span class="ot">=</span> <span class="kw">true</span> <span class="kw">else</span> tileAdjacency<span class="ot">.</span>top<span class="ot">[</span>j<span class="ot">]</span> <span class="ot">=</span> <span class="kw">false</span> <span class="kw">end</span> <span class="kw">end</span> <span class="ot">...</span> <span class="do">-- bottom, left, and right adjacencies go here, but it&#39;s a bit redundant</span> <span class="fu">table.insert</span><span class="ot">(</span>wfc<span class="ot">.</span>adjacencyIndex<span class="ot">,</span> tileAdjacency<span class="ot">)</span> <span class="kw">end</span></code></pre></div> <p>Let's break that up, shall we?</p> <p>First of all, we're going through the list of tiles we made in the tile generation phase (see <a href="https://flber.github.io/2020/WFC-Tile-Generator/">this</a> article for a description of how that works):</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">for</span> i <span class="ot">=</span> <span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>wfc<span class="ot">.</span>tiles <span class="kw">do</span></code></pre></div> <p>Then, we set a local variable to the tile we're checking, and make a new &quot;tileAdjacency&quot; table which will store the top, bottom, left, and right adjacency information:</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> currentTile <span class="ot">=</span> wfc<span class="ot">.</span>tiles<span class="ot">[</span>i<span class="ot">]</span> <span class="kw">local</span> tileAdjacency <span class="ot">=</span> <span class="ot">{}</span></code></pre></div> <p>We add a table called &quot;top&quot; to the &quot;tileAdjacency&quot; table, which will store the top adjacency data, and then start to loop through the list of tiles again:</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">tileAdjacency<span class="ot">.</span>top <span class="ot">=</span> <span class="ot">{}</span> <span class="kw">for</span> j <span class="ot">=</span> <span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>wfc<span class="ot">.</span>tiles <span class="kw">do</span></code></pre></div> <p>Now we create a local &quot;checkTile&quot; variable to store the tile we're looking at, and check if the color data of the bottom of that tile is the same as the color data of the top of our current tile</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> checkTile <span class="ot">=</span> wfc<span class="ot">.</span>tiles<span class="ot">[</span>j<span class="ot">]</span> <span class="kw">if</span> checkTile<span class="ot">.</span>color<span class="ot">.</span>bottom <span class="ot">==</span> currentTile<span class="ot">.</span>color<span class="ot">.</span>top <span class="kw">then</span></code></pre></div> <p>If it is, then we know that it can go above the current tile. To save that, we set the &quot;top&quot; tile adjacency at the index of that tile to true</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">tileAdjacency<span class="ot">.</span>top<span class="ot">[</span>j<span class="ot">]</span> <span class="ot">=</span> <span class="kw">true</span></code></pre></div> <p>But if the colors aren't the same, then we set the &quot;top&quot; tile adjacency to false</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">else</span> tileAdjacency<span class="ot">.</span>top<span class="ot">[</span>j<span class="ot">]</span> <span class="ot">=</span> <span class="kw">false</span> <span class="kw">end</span></code></pre></div> <p>With the &quot;top&quot; tile adjacency constructed we move onto the bottom, left, and right adjacencies (which I'll skip over because they're the same as the top one), and then we can finally add all of those in the form of the tileAdjacency variable to the overall adjacencyIndex table.</p> <div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="fu">table.insert</span><span class="ot">(</span>wfc<span class="ot">.</span>adjacencyIndex<span class="ot">,</span> tileAdjacency<span class="ot">)</span></code></pre></div> <p>And with that we're done! Hopefully this helped to explain how the propagator constructor works, as well as what the structure of the adjacencyIndex looks like.</p>
